% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/association_functions.R
\name{run_genomic_prediction}
\alias{run_genomic_prediction}
\title{Interface with BGLR to run genomic prediction with snpRdata objects.}
\usage{
run_genomic_prediction(
  x,
  facets = NULL,
  response,
  iterations,
  burn_in,
  thin,
  model = "BayesB",
  interpolate = "bernoulli",
  ncp = NULL,
  ncp.max = 5,
  par = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{snpRdata object}

\item{facets}{character, default NULL. Categorical metadata variables by
which to break up analysis. See \code{\link{Facets_in_snpR}} for more
details.}

\item{response}{character. Name of the column containing the response
variable of interest. Must match a column name in sample metadata.}

\item{iterations}{numeric. Number of iterations to run the MCMC chain for.}

\item{burn_in}{numeric. Number of burn in iterations to run prior to the MCMC
chain.}

\item{thin}{numeric. Number of iterations to discard between each recorded
data point.}

\item{model}{character, default "BayesB". Prediction model to use, see
description for the ETA argument in \code{\link[BGLR]{BGLR}}.}

\item{interpolate}{character, default "bernoulli". Interpolation method for
missing data. Options: \itemize{\item{bernoulli: }binomial draws for the
minor allele. \item{af: } insertion of the average allele frequency
\item{iPCA:} As a slower but more accurate alternative to "af"
interpolation, "iPCA" may be selected. This an iterative PCA approach to
interpolate based on SNP/SNP covariance via
\code{\link[missMDA]{imputePCA}}. If the ncp argument is not defined, the
number of components used for interpolation will be estimated using
\code{\link[missMDA]{estim_ncpPCA}}. In this case, this method is much
slower than the other methods, especially for large datasets. Setting an
ncp of 2-5 generally results in reasonable interpolations without the time
constraint.}.}

\item{ncp}{numeric or NULL, default NULL. Used only if \code{iPCA}
interpolation is selected. Number of components to consider for iPCA sn
format interpolations of missing data. If null, the optimum number will be
estimated, with the maximum specified by ncp.max. This can be very slow.}

\item{ncp.max}{numeric, default 5. Used only if \code{iPCA}
interpolation is selected. Maximum number of components to check for
when determining the optimum number of components to use when interpolating
sn data using the iPCA approach.}

\item{par}{numeric or FALSE, default FALSE. If a number specifies the number
of processing cores to use \emph{across facet levels}. Not used if only one
facet level.}

\item{verbose}{Logical, default FALSE. If TRUE, some progress updates will be
printed to the console.}

\item{...}{additional arguments passed to \code{\link[BGLR]{BGLR}}}
}
\value{
A list containing: two parts: \itemize{\item{x: } The provided
  snpRdata object with effect sizes merged in. \item{models: } Other model
  results, a list containing: \itemize{ \item{model: } The model output from
  BGLR. See \code{\link[BGLR]{BGLR}}. \item{h2: } Estimated heritability of
  the response variable.\item{predictions: } A data.frame containing the
  provided phenotypes and the predicted Breeding Values (BVs) for those
  phenotypes. }}
}
\description{
Run genomic prediction given a single response variable (usually a phenotype)
using the \code{\link[BGLR]{BGLR}} function. Unlike other snpR functions,
this returns the resulting model directly, so overwrite with caution.
}
\details{
This function is provided as a wrapper to plug snpRdata objects into the
\code{\link[BGLR]{BGLR}} function in order to easily run genomic prediction
on a simple model where a single, sample specific meta data variable is
provided as the response variable. To do so, this function formats the data
into a transposed "sn" format, as described in \code{\link{format_snps}}
using the bernoulli method to interpolate missing genotypes. Several
different prediction models are available, see the documentation the ETA
argument in \code{\link[BGLR]{BGLR}} for details. Defaults to the "BayesB"
model, which assumes a "spike-slab" prior for allele effects on phenotype
where most markers have a very small effect size and a few can have a much
larger effect.

Unlike most snpR functions, this function does not support facets, since each
run can be very slow. Instead, an individual facet and facet level of
interest should be selected with \code{\link{subset_snpR_data}}. See
examples.

See documentation for \code{\link[BGLR]{BGLR}} for more details and for a
full list of references.
}
\examples{
# run and plot a basic prediction
## add some dummy phenotypic data.
dat <- stickSNPs
sample.meta(dat) <- cbind(weight = rnorm(ncol(stickSNPs)), 
                          sample.meta(stickSNPs))
## run prediction
gp <- run_genomic_prediction(dat, response = "weight", iterations = 1000, 
                             burn_in = 100, thin = 10)
## dummy phenotypes vs. predicted Breeding Values for dummy predictions.
# given that weight was randomly assigned, definitely overfit!
with(gp$models$.base_.base$predictions, plot(phenotype, predicted_BV)) 
## fetch estimated loci effects
get.snpR.stats(gp$x, stats = "genomic_prediction")

\dontrun{
# with facets, not run
gp <- run_genomic_prediction(gp$x, facets = "pop", response = "weight", 
                             iterations = 1000, burn_in = 100, thin = 10)
get.snpR.stats(gp$x, facets = "pop", stats = "genomic_prediction")
}
}
\references{
PÃ©rez, P., and de los Campos, G. (2014). \emph{Genetics}.
}
\author{
William Hemstrom
}
